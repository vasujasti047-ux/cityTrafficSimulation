# -*- coding: utf-8 -*-
"""fundamentals of AI part-A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JMTVJ154najVcultVtNOryUNG1iUbreC
"""

import networkx as nx
import random
import numpy as np

# -------------------------------
# PARAMETERS (from assumptions)
# -------------------------------
N = 60                  # number of intersections
p = 0.05                # initial connection probability
L_min, L_max = 5, 25    # road length range
TOTAL_TIME = 36000      # total time (10 hours)
T = 100                 # trips per second
f = 0.6                 # shrinkage factor
k = 3                   # number of new roads allowed
random.seed(42)
np.random.seed(42)

# -------------------------------
# PHASE 1: NETWORK CREATION
# -------------------------------
def build_graph(N, p, L_min, L_max):
    # Keep generating until connected
    G = None
    while True:
        G = nx.erdos_renyi_graph(N, p)
        if nx.is_connected(G):
            break
        p += 0.01  # increase p until connected

    # Assign random weights (road lengths)
    for (u, v) in G.edges():
        G[u][v]['weight'] = random.randint(L_min, L_max)
    return G

# -------------------------------
# PHASE 2: TRIP SIMULATION
# -------------------------------
def simulate_trips(G, TOTAL_TIME, T):
    usage_counter = {edge: 0 for edge in G.edges()}
    trip_matrix = np.zeros((N, N), dtype=int)

    nodes = list(G.nodes())

    for _ in range(TOTAL_TIME * T):
        start, end = random.sample(nodes, 2)
        path = nx.shortest_path(G, source=start, target=end, weight='weight')

        # Increment usage for each edge
        for i in range(len(path)-1):
            edge = (path[i], path[i+1])
            if edge not in usage_counter:
                edge = (path[i+1], path[i])  # undirected
            usage_counter[edge] += 1

        trip_matrix[start, end] += 1

    return usage_counter, trip_matrix

# -------------------------------
# PHASE 3: BENEFIT ANALYSIS
# -------------------------------
def evaluate_benefits(G, trip_matrix, f):
    benefit_matrix = {}
    nodes = list(G.nodes())

    for i in range(len(nodes)):
        for j in range(i+1, len(nodes)):
            if not G.has_edge(i, j):
                try:
                    dist = nx.shortest_path_length(G, source=i, target=j, weight='weight')
                except nx.NetworkXNoPath:
                    continue
                reduced_dist = dist * f
                trip_count = trip_matrix[i, j]
                benefit = (dist - reduced_dist) * trip_count
                benefit_matrix[(i, j)] = benefit

    return benefit_matrix

# -------------------------------
# PHASE 4: ROAD SELECTION
# -------------------------------
def pick_new_roads(G, benefit_matrix, k):
    new_roads = []
    benefit_sorted = sorted(benefit_matrix.items(), key=lambda x: x[1], reverse=True)

    for (u, v), benefit in benefit_sorted[:k]:
        G.add_edge(u, v, weight=int((L_min + L_max) / 2))  # assign avg length
        new_roads.append((u, v, benefit))
    return new_roads

# -------------------------------
# MAIN PROGRAM
# -------------------------------
if __name__ == "__main__":
    print("Building graph...")
    G = build_graph(N, p, L_min, L_max)

    print("Simulating trips...")
    usage_data, trip_matrix = simulate_trips(G, TOTAL_TIME=10, T=2)
    # âš  Reduced numbers for faster testing; use (TOTAL_TIME, T) in real run

    print("Evaluating benefits...")
    benefit_matrix = evaluate_benefits(G, trip_matrix, f)

    print("Selecting new roads...")
    proposed_roads = pick_new_roads(G, benefit_matrix, k)

    print("\nProposed Roads (top k):")
    for u, v, b in proposed_roads:
        print(f"Road between {u} and {v} | Benefit: {b:.2f}")